"use strict";(()=>{var e={};e.id=229,e.ids=[229],e.modules={399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},6320:(e,r,t)=>{t.r(r),t.d(r,{originalPathname:()=>g,patchFetch:()=>y,requestAsyncStorage:()=>h,routeModule:()=>u,serverHooks:()=>f,staticGenerationAsyncStorage:()=>m});var i={};t.r(i),t.d(i,{POST:()=>d,dynamic:()=>l});var s=t(921),o=t(7380),a=t(4185),n=t(3878),p=t(9382);let l="force-dynamic";async function c(e){try{console.log(`Fetching real-time prices for item: ${e}`);let r=process.env.NEXT_PUBLIC_APP_URL||"http://localhost:3000",t=await fetch(`${r}/api/real-time-prices?item=${encodeURIComponent(e)}`,{cache:"no-store",headers:{"Content-Type":"application/json"}});if(!t.ok)throw Error(`Failed to fetch real-time prices: ${t.status} ${t.statusText}`);let i=await t.json();if(!Array.isArray(i)||0===i.length)throw Error("Invalid price data received");return console.log(`Successfully fetched prices for ${e} from ${i.length} platforms`),i}catch(e){return console.error("Error fetching real-time prices:",e),null}}async function d(e,{params:r}){try{console.log(`Refreshing prices for shopping list: ${r.id}`);let e=await p._.shoppingItem.findMany({where:{shoppingListId:r.id},include:{prices:!0}});console.log(`Found ${e.length} items to refresh prices for`);let t=0,i=0;for(let r of e){let e=await c(r.name);if(e&&Array.isArray(e)&&e.length>0){await p._.itemPrice.deleteMany({where:{shoppingItemId:r.id}});let i=e.map(e=>({platform:e.platform,price:e.price,available:e.available,url:e.url,productName:e.productName,imageUrl:e.imageUrl,shoppingItemId:r.id,lastUpdated:new Date}));await p._.itemPrice.createMany({data:i}),console.log(`Successfully updated prices for item: ${r.name} (${e.length} platforms)`),t++}else{if(console.error(`Failed to fetch new prices for item: ${r.name}`),r.prices&&r.prices.length>0){for(let e of r.prices)await p._.itemPrice.update({where:{id:e.id},data:{lastUpdated:new Date}});console.log(`Updated timestamps for existing prices for item: ${r.name}`)}i++}}return console.log(`Price refresh complete. Success: ${t}, Failures: ${i}`),n.NextResponse.json({success:!0,summary:{total:e.length,success:t,failure:i}})}catch(e){return console.error("Error refreshing prices:",e),n.NextResponse.json({error:"Failed to refresh prices"},{status:500})}}let u=new s.AppRouteRouteModule({definition:{kind:o.x.APP_ROUTE,page:"/api/shopping-lists/[id]/refresh-prices/route",pathname:"/api/shopping-lists/[id]/refresh-prices",filename:"route",bundlePath:"app/api/shopping-lists/[id]/refresh-prices/route"},resolvedPagePath:"/home/ubuntu/grocery_price_comparison/app/app/api/shopping-lists/[id]/refresh-prices/route.ts",nextConfigOutput:"",userland:i}),{requestAsyncStorage:h,staticGenerationAsyncStorage:m,serverHooks:f}=u,g="/api/shopping-lists/[id]/refresh-prices/route";function y(){return(0,a.patchFetch)({serverHooks:f,staticGenerationAsyncStorage:m})}},9382:(e,r,t)=>{t.d(r,{_:()=>s});let i=require("@prisma/client"),s=global.prisma||new i.PrismaClient({log:["query"]})}};var r=require("../../../../../webpack-runtime.js");r.C(e);var t=e=>r(r.s=e),i=r.X(0,[923,146],()=>t(6320));module.exports=i})();